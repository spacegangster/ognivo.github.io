// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['./Emitter', './functions'], function(Emitter, functions) {
    var SuperEmitter, bind, contains, find_by_first_value_as_key, listen, make_action_undefined_exception, map, mutate_list, partial, remove_at, to_emitter_row, values;
    bind = functions.bind, contains = functions.contains, find_by_first_value_as_key = functions.find_by_first_value_as_key, map = functions.map, partial = functions.partial, remove_at = functions.remove_at, values = functions.values;
    make_action_undefined_exception = function(action, emitter_name) {
      return new Error("ListeningError: action " + action + " is undefined for " + emitter_name);
    };
    listen = function(emitter, event_table, this_arg) {
      var action, actions, bound, bounds, event, _i, _j, _len, _len1, _ref;
      if (!emitter) {
        return;
      }
      bounds = this_arg.__bounds__;
      for (_i = 0, _len = event_table.length; _i < _len; _i++) {
        _ref = event_table[_i], event = _ref[0], actions = _ref[1];
        for (_j = 0, _len1 = actions.length; _j < _len1; _j++) {
          action = actions[_j];
          bound = ((typeof action === 'function') && action) || bounds[action] || (bounds[action] = bind(this_arg[action], this_arg));
          if ((typeof action === 'string') && !this_arg[action]) {
            throw make_action_undefined_exception;
          }
          emitter.on(event, bound);
        }
      }
    };
    mutate_list = function(list, events, this_arg) {
      var push, splice, unshift;
      push = list.push, splice = list.splice, unshift = list.unshift;
      list.splice = function() {
        var i;
        i = arguments.length;
        while (--i > 1) {
          listen(arguments[i], events, this_arg);
        }
        return old_splice.apply(list, arguments);
      };
      list.push = function() {
        var emitter, _i, _len;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          emitter = arguments[_i];
          listen(emitter, events, this_arg);
        }
        return old_push.apply(list, arguments);
      };
      list.unshift = function() {
        var emitter, _i, _len;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          emitter = arguments[_i];
          listen(emitter, events, this_arg);
        }
        return old_unshift.apply(list, arguments);
      };
      return 0;
    };
    to_emitter_row = function(this_arg, _arg) {
      var emitter_name, events, find_selector, jElement_name, _ref;
      emitter_name = _arg[0], events = _arg[1];
      if ('string' !== typeof emitter_name) {
        return [emitter_name, events];
      } else if (emitter_name.indexOf(':') === -1) {
        return [this_arg[emitter_name], events];
      } else {
        _ref = emitter_name.split(':'), jElement_name = _ref[0], find_selector = _ref[1];
        return [this_arg[jElement_name].find(find_selector), events];
      }
    };
    SuperEmitter = (function(_super) {
      __extends(SuperEmitter, _super);

      function SuperEmitter() {
        SuperEmitter.__super__.constructor.call(this);
        this.__bounds__ = {};
        this.self = this;
      }

      SuperEmitter.prototype.bind_events = function() {
        var emitter, events, item, _i, _j, _len, _len1, _ref, _ref1;
        _ref = map(partial(to_emitter_row, this), this.event_table);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], emitter = _ref1[0], events = _ref1[1];
          if (Array.isArray(emitter)) {
            mutate_list(emitter, events, this);
            if (emitter.length) {
              for (_j = 0, _len1 = emitter.length; _j < _len1; _j++) {
                item = emitter[_j];
                listen(item, events, this);
              }
            }
          } else {
            listen(emitter, events, this);
          }
        }
        return 0;
      };

      SuperEmitter.prototype.listen = function(emitter_name, emitter) {
        listen(emitter, find_by_first_value_as_key(this.event_table, emitter_name), this);
        return emitter;
      };

      SuperEmitter.prototype.remove_listener = function(listener) {
        var event_name, handler, handler_bundle, handler_idx, listener_bounds, _i, _ref;
        listener_bounds = values(listener.__bounds__);
        _ref = this.handlers;
        for (event_name in _ref) {
          handler_bundle = _ref[event_name];
          for (handler_idx = _i = handler_bundle.length - 1; _i >= 0; handler_idx = _i += -1) {
            handler = handler_bundle[handler_idx];
            if (contains(handler, listener_bounds)) {
              remove_at(handler_bundle, handler_idx);
            }
          }
        }
      };

      return SuperEmitter;

    })(Emitter);

    /*
    Performs bindings of event handlers without instance binding.
    All emitters should be objects not strings, and all actions must functions,
    not the method names.
     */
    SuperEmitter.activate_event_table = function(table) {};
    return SuperEmitter;
  });

}).call(this);
